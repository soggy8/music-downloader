from fastapi import BackgroundTasks, FastAPI, HTTPException, Query, Request
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from urllib.parse import quote, unquote
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, HTMLResponse
from pydantic import BaseModel
from typing import List, Optional, Dict
import os
import re
import sys
import shutil
from pathlib import Path
import time

# Add parent directory to path for imports
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

import config
from services.spotify import SpotifyService
from utils.job_store import init_jobs_db, upsert_job, get_job, get_album_aggregate


def get_system_downloads_folder():
    """Get the user's system Downloads folder"""
    home = Path.home()

    # Check common Downloads folder locations
    if os.name == 'nt':  # Windows
        downloads = home / "Downloads"
    else:  # Linux/Mac
        downloads = home / "Downloads"

    # Create if doesn't exist
    downloads.mkdir(parents=True, exist_ok=True)
    return str(downloads)


from services.youtube import YouTubeService
from services.metadata import MetadataService
from services.navidrome import NavidromeService
from utils.file_handler import get_download_path

app = FastAPI(title="Music Downloader API", version="1.0.0")

init_jobs_db()

# CORS middleware (still useful for API endpoints)
app.add_middleware(
    CORSMiddleware,
    allow_origins=config.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# Initialize services
try:
    spotify_service = SpotifyService()
except Exception as e:
    print(f"Warning: Spotify service initialization failed: {e}")
    spotify_service = None

youtube_service = YouTubeService()
metadata_service = MetadataService()
navidrome_service = NavidromeService()


# Request models
class SearchRequest(BaseModel):
    query: str
    limit: Optional[int] = 20


class DownloadRequest(BaseModel):
    track_id: str
    location: Optional[str] = "local"  # 'local' or 'navidrome'
    video_id: Optional[str] = None  # YouTube video ID if user selected a specific candidate


class AlbumDownloadRequest(BaseModel):
    album_id: str
    location: Optional[str] = "local"  # 'local' or 'navidrome'


class ReverseLookupRequest(BaseModel):
    url: str


class ReverseDownloadRequest(BaseModel):
    youtube_url: str
    location: Optional[str] = "local"  # 'local' or 'navidrome'
    spotify_track_id: Optional[str] = None
    metadata: Optional[Dict] = None


# Response models
class TrackResponse(BaseModel):
    id: str
    name: str
    artist: str
    artists: List[str]
    album: str
    duration_ms: int
    external_url: str
    preview_url: Optional[str]
    album_art: Optional[str]
    release_date: str


class DownloadStatusResponse(BaseModel):
    status: str
    message: str
    file_path: Optional[str] = None


def download_and_process(track_id: str, location: str = "local", video_id: str = None):
    """Background task to download and process a track"""
    try:
        upsert_job(
            track_id,
            status="processing",
            message="Fetching track info...",
            stage="fetching",
            progress=10,
        )

        # Get track details from Spotify
        track_info = spotify_service.get_track_details(track_id)
        if not track_info:
            upsert_job(track_id,
                       status="error",
                       message="Could not fetch track information",
                       progress=0
                       )
            return

        upsert_job(track_id, status="processing", message="Preparing download location...", stage="preparing",
                   progress=15)

        # Determine download path based on location preference
        if location == "navidrome":
            # Download directly to Navidrome music directory with proper structure (Artist/Album/)
            # First download to temp location, then copy to Navidrome directory
            temp_dir = os.path.join(config.DOWNLOAD_DIR, "temp")
            Path(temp_dir).mkdir(parents=True, exist_ok=True)
            download_path = get_download_path(track_info, temp_dir, config.OUTPUT_FORMAT)
            print(f"Downloading track {track_id} for Navidrome: {download_path}")
        else:
            # For local downloads: download to temp folder, then serve via browser download
            # This allows each user's browser to save to their own Downloads folder
            temp_dir = os.path.join(config.DOWNLOAD_DIR, "temp")
            Path(temp_dir).mkdir(parents=True, exist_ok=True)
            download_path = get_download_path(track_info, temp_dir, config.OUTPUT_FORMAT)
            print(f"Downloading track {track_id} for local browser download: {download_path}")

        upsert_job(track_id,
                   status="processing",
                   message="Searching YouTube and downloading...",
                   stage="downloading",
                   progress=30)

        # Download - pass full track_info for better matching
        # If video_id is provided, download that specific video
        download_result = youtube_service.search_and_download(
            track_info['name'],
            track_info['artist'],
            download_path,
            track_info,  # Pass full track info for validation
            video_id  # Specific YouTube video if user selected one
        )

        if not download_result.get("success"):
            upsert_job(
                track_id,
                status="error",
                message=f"Download failed: {download_result.get('error', 'Unknown error')}",
                progress=0,
            )
            return

        upsert_job(track_id,
                   status="processing",
                   message="Applying metadata...",
                   stage="tagging",
                   progress=85)

        # Apply metadata to downloaded file
        metadata_service.apply_metadata(download_result['file_path'], track_info)

        # Handle completion based on location
        if location == "navidrome":
            # Copy to Navidrome music directory with proper structure (Artist/Album/)
            upsert_job(track_id,
                       status="processing",
                       message="Copying to Navidrome library...",
                       stage="copying",
                       progress=90)

            try:
                # Get target path in Navidrome directory (Artist/Album/filename.mp3)
                target_path = navidrome_service.get_target_path(track_info, config.OUTPUT_FORMAT)

                # Copy file to Navidrome directory
                shutil.copy2(download_result['file_path'], target_path)

                # Clean up temp file
                if os.path.exists(download_result['file_path']):
                    os.remove(download_result['file_path'])

                # Trigger Navidrome scan
                navidrome_result = navidrome_service.finalize_track(str(target_path))

                if navidrome_result.get('success'):
                    upsert_job(track_id,
                               status="completed",
                               message="Track successfully added to Navidrome library",
                               file_path=str(target_path),
                               stage="completed",
                               progress=100
                               )

                else:
                    upsert_job(track_id,
                               status="completed",
                               message=f"Track added to library (scan may need manual trigger): {navidrome_result.get('error', '')}",
                               file_path=str(target_path),
                               stage="completed",
                               progress=100
                               )

            except Exception as e:
                upsert_job(track_id,
                           status="error",
                           message=f"Failed to copy to Navidrome: {str(e)}",
                           progress=0
                           )
        else:
            # For local downloads, provide download URL for browser to handle
            # The file is ready, browser will download it to user's Downloads folder
            filename = os.path.basename(download_result['file_path'])
            # URL encode the filename to handle special characters (use query parameter)
            encoded_filename = quote(filename, safe='')
            download_url = f"api/download/file/{track_id}?filename={encoded_filename}"
            upsert_job(track_id,
                       status="completed",
                       message="Track ready for download",
                       file_path=download_result['file_path'],
                       download_url=download_url,  # URL to trigger browser download
                       stage="completed",
                       progress=100
                       )

    except Exception as e:
        upsert_job(track_id,
                   status="error",
                   message=f"Error: {str(e)}",
                   progress=0
                   )


@app.middleware("http")
async def add_root_path(request: Request, call_next):
    root_path = request.headers.get("X-Forwarded-Prefix", "")
    request.scope["root_path"] = root_path
    return await call_next(request)


@app.get("/", response_class=HTMLResponse)
async def root(request: Request):
    """Serve the frontend index.html"""
    template_name = "index.html"
    return templates.TemplateResponse(template_name, context={"request": request})


@app.post("/api/search", response_model=List[TrackResponse])
async def search_tracks(request: SearchRequest):
    """Search for tracks on Spotify"""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    try:
        tracks = spotify_service.search_tracks(request.query, request.limit)
        return tracks
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")


@app.post("/api/reverse/youtube")
async def reverse_lookup_youtube(request: ReverseLookupRequest):
    """Given a YouTube/YouTube Music URL, extract title via yt-dlp and search Spotify."""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    try:
        yt_info = youtube_service.extract_video_info(request.url)
        if not yt_info.get('success'):
            raise HTTPException(status_code=400,
                                detail=f"Failed to read YouTube URL: {yt_info.get('error', 'Unknown error')}")

        title = (yt_info.get('title') or '').strip()
        if not title:
            raise HTTPException(status_code=400, detail="YouTube title was empty")

        spotify_candidates = spotify_service.search_tracks(title, limit=5)

        return {
            "youtube": yt_info,
            "query": title,
            "spotify_candidates": spotify_candidates
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Reverse lookup failed: {str(e)}")


@app.post("/api/search/tracks/top")
async def search_tracks_top(request: SearchRequest):
    """Search for tracks on Spotify with a small, fixed default suitable for pick-lists."""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    try:
        limit = request.limit or 5
        limit = max(1, min(int(limit), 10))
        return spotify_service.search_tracks(request.query, limit=limit)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")


@app.post("/api/search/albums")
async def search_albums(request: SearchRequest):
    """Search for albums on Spotify"""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    try:
        albums = spotify_service.search_albums(request.query, request.limit)
        return albums
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Album search failed: {str(e)}")


@app.get("/api/album/{album_id}")
async def get_album(album_id: str):
    """Get album details including all tracks"""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    try:
        album = spotify_service.get_album_details(album_id)
        if not album:
            raise HTTPException(status_code=404, detail="Album not found")
        return album
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching album: {str(e)}")


@app.get("/api/track/{track_id}", response_model=TrackResponse)
async def get_track(track_id: str):
    """Get details for a specific track"""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    try:
        track = spotify_service.get_track_details(track_id)
        if not track:
            raise HTTPException(status_code=404, detail="Track not found")
        return track
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching track: {str(e)}")


@app.post("/api/download")
async def download_track(request: DownloadRequest, background_tasks: BackgroundTasks):
    """Start downloading a track"""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    # Validate location
    if request.location not in ["local", "navidrome"]:
        request.location = "local"  # Default to local

    # Initialize status
    location_msg = "local downloads folder" if request.location == "local" else "Navidrome server"
    upsert_job(request.track_id,
               status="queued",
               message=f"Download queued for {location_msg}",
               progress=0,
               stage="queued"
               )

    # Add background task with location and video_id parameters
    background_tasks.add_task(download_and_process, request.track_id, request.location, request.video_id)

    return {
        "status": "queued",
        "message": f"Download started to {location_msg}",
        "track_id": request.track_id
    }


def reverse_download_and_process(job_id: str, youtube_url: str, location: str, spotify_track_id: Optional[str],
                                 metadata: Optional[Dict]):
    """Background task: download a specific YouTube URL and tag using either Spotify track or manual metadata."""
    try:
        upsert_job(job_id, status="processing", message="Extracting YouTube info...", stage="fetching", progress=10)

        yt_info = youtube_service.extract_video_info(youtube_url)
        if not yt_info.get('success'):
            upsert_job(job_id, status="error",
                       message=f"Failed to read YouTube URL: {yt_info.get('error', 'Unknown error')}", progress=0)
            return

        video_id = yt_info.get('video_id')
        if not video_id:
            upsert_job(job_id, status="error", message="Could not determine YouTube video id", progress=0)
            return

        track_info: Optional[Dict] = None
        if spotify_track_id:
            upsert_job(job_id, status="processing", message="Fetching Spotify track info...", stage="fetching",
                       progress=20)
            track_info = spotify_service.get_track_details(spotify_track_id)
            if not track_info:
                upsert_job(job_id, status="error", message="Could not fetch Spotify track information", progress=0)
                return
        else:
            # Validate manual metadata (name + artist required)
            md = metadata or {}
            name = (md.get('name') or md.get('title') or '').strip()
            artist = (md.get('artist') or '').strip()
            if not name or not artist:
                upsert_job(job_id, status="error", message="Manual metadata requires 'name' (song title) and 'artist'",
                           progress=0)
                return

            # Default album/album_artist to "YouTube" if not provided
            album_artist = (md.get('album_artist') or '').strip() or "YouTube"
            album = (md.get('album') or md.get('album_name') or '').strip() or "YouTube"

            # If user didn't provide album art, use YouTube thumbnail
            album_art = md.get('album_art') or yt_info.get('thumbnail') or None

            track_info = {
                'id': job_id,
                'name': name,
                'artist': artist,
                'artists': [a.strip() for a in re.split(r"[;,]", artist) if a.strip()],
                'album_artist': album_artist,
                'album': album,
                'track_number': int(md.get('track_number') or 1),
                'release_date': (md.get('release_date') or '').strip(),
                'album_art': album_art,
                'duration_ms': 0,
                'external_url': yt_info.get('webpage_url') or youtube_url,
                'preview_url': None,
            }

        upsert_job(job_id, status="processing", message="Preparing download location...", stage="preparing",
                   progress=20)

        # Determine download path
        temp_dir = os.path.join(config.DOWNLOAD_DIR, "temp")
        Path(temp_dir).mkdir(parents=True, exist_ok=True)
        download_path = get_download_path(track_info, temp_dir, config.OUTPUT_FORMAT)

        upsert_job(job_id, status="processing", message="Downloading from YouTube...", stage="downloading", progress=40)
        download_result = youtube_service.download_by_video_id(video_id, download_path)
        if not download_result.get('success'):
            upsert_job(job_id, status="error",
                       message=f"Download failed: {download_result.get('error', 'Unknown error')}", progress=0)
            return

        upsert_job(job_id, status="processing", message="Applying metadata...", stage="tagging", progress=80)
        metadata_service.apply_metadata(download_result['file_path'], track_info)

        # Handle completion based on location
        if location == "navidrome":
            upsert_job(job_id, status="processing", message="Copying to Navidrome library...", stage="copying",
                       progress=90)
            try:
                target_path = navidrome_service.get_target_path(track_info, config.OUTPUT_FORMAT)
                shutil.copy2(download_result['file_path'], target_path)
                if os.path.exists(download_result['file_path']):
                    os.remove(download_result['file_path'])

                navidrome_result = navidrome_service.finalize_track(str(target_path))
                upsert_job(job_id,
                           status="completed",
                           message="Track successfully added to Navidrome library" if navidrome_result.get(
                               'success') else f"Track added to library (scan may need manual trigger): {navidrome_result.get('error', '')}",
                           file_path=str(target_path),
                           stage="completed",
                           progress=100,
                           )
            except Exception as e:
                upsert_job(job_id, status="error", message=f"Failed to copy to Navidrome: {str(e)}", progress=0)
        else:
            filename = os.path.basename(download_result['file_path'])
            encoded_filename = quote(filename, safe='')
            download_url = f"api/download/file/{job_id}?filename={encoded_filename}"
            upsert_job(job_id,
                       status="completed",
                       message="Track ready for download",
                       file_path=download_result['file_path'],
                       download_url=download_url,
                       stage="completed",
                       progress=100,
                       )

    except Exception as e:
        upsert_job(job_id, status="error", message=f"Error: {str(e)}", progress=0)


@app.post("/api/reverse/download")
async def reverse_download(request: ReverseDownloadRequest, background_tasks: BackgroundTasks):
    """Finalize reverse flow: download YouTube URL and tag with chosen Spotify track or manual metadata."""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    # Validate location
    location = request.location if request.location in ["local", "navidrome"] else "local"
    location_msg = "local downloads folder" if location == "local" else "Navidrome server"

    # Create a synthetic job id (stable enough for polling)
    job_id = f"yt-{abs(hash((request.youtube_url, request.spotify_track_id or '', location))) % 10_000_000}"

    upsert_job(job_id,
               status="queued",
               message=f"Reverse download queued for {location_msg}",
               progress=0,
               stage="queued",
               )

    background_tasks.add_task(
        reverse_download_and_process,
        job_id,
        request.youtube_url,
        location,
        request.spotify_track_id,
        request.metadata,
    )

    return {
        "status": "queued",
        "message": f"Reverse download started to {location_msg}",
        "job_id": job_id,
    }


@app.get("/api/download/status/{track_id}")
async def get_download_status(track_id: str):
    job = get_job(track_id)
    if not job:
        raise HTTPException(status_code=404, detail="Download not found")
    # Keep response shape compatible with old dict
    return {
        "status": job.get("status"),
        "message": job.get("message"),
        "stage": job.get("stage"),
        "progress": job.get("progress"),
        "file_path": job.get("file_path"),
        "download_url": job.get("download_url"),
        "error": job.get("error"),
    }


@app.post("/api/download/album")
async def download_album(request: AlbumDownloadRequest, background_tasks: BackgroundTasks):
    """Start downloading all tracks from an album"""

    album_job_id = f"album:{request.album_id}"

    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    # Get album details
    album = spotify_service.get_album_details(request.album_id)

    if not album:
        raise HTTPException(status_code=404, detail="Album not found")

    upsert_job(
        album_job_id,
        status="queued",
        message=f"Album '{album['name']}' queued",
        stage="queued",
        progress=0,
        album_id=request.album_id,
        payload={
            "album_id": request.album_id,
            "album_name": album["name"],
            "artist": album["artist"],
            "track_ids": [t["id"] for t in album["tracks"]],
            "total_tracks": len(album["tracks"]),
        },
    )

    # Validate location
    location = request.location if request.location in ["local", "navidrome"] else "local"
    location_msg = "local downloads folder" if location == "local" else "Navidrome server"

    # Queue each track for download
    for track in album['tracks']:
        upsert_job(track['id'],
                   status="queued",
                   message=f"Queued (Album: {album['name']})",
                   progress=0,
                   stage="queued",
                   album_id=request.album_id
                   )
        background_tasks.add_task(download_album_track, track['id'], location, request.album_id)

    return {
        "status": "queued",
        "message": f"Album '{album['name']}' queued for download to {location_msg}",
        "album_id": request.album_id,
        "total_tracks": len(album['tracks'])
    }


def download_album_track(track_id: str, location: str, album_id: str):
    try:
        download_and_process(track_id, location, None)
    except Exception as e:
        print(f"Error downloading album track {track_id}: {e}")



@app.get("/api/download/album/status/{album_id}")
async def get_album_download_status(album_id: str):
    album_job_id = f"album:{album_id}"
    meta_job = get_job(album_job_id)

    agg = get_album_aggregate(album_id, exclude_job_id=album_job_id)

    if not meta_job:
        # fallback: als iemand status opvraagt zonder dat album ooit gestart is
        raise HTTPException(status_code=404, detail="Album download not found")

    payload = meta_job.get("payload") or {}

    return {
        "status": agg["status"],
        "album_name": payload.get("album_name"),
        "artist": payload.get("artist"),
        "total_tracks": payload.get("total_tracks") or agg["total_tracks"],
        "completed_tracks": agg["completed_tracks"],
        "failed_tracks": agg["failed_tracks"],
        "current_track": agg["current_track"],
        "track_ids": payload.get("track_ids") or [],
    }



@app.get("/api/youtube/candidates/{track_id}")
async def get_youtube_candidates(track_id: str):
    """Get YouTube candidates for a track to let user choose if confidence is low"""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    try:
        # Get track details from Spotify
        track_info = spotify_service.get_track_details(track_id)
        if not track_info:
            raise HTTPException(status_code=404, detail="Track not found")

        # Search YouTube for candidates
        result = youtube_service.search_candidates(
            track_info['name'],
            track_info['artist'],
            track_info
        )

        return {
            "track": {
                "id": track_id,
                "name": track_info['name'],
                "artist": track_info['artist'],
                "album": track_info.get('album', '')
            },
            **result
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error searching YouTube: {str(e)}")


@app.get("/api/download/file/{track_id}")
async def download_file(track_id: str, filename: str = Query(...),
                        background_tasks: BackgroundTasks = BackgroundTasks()):
    """Download a file (for local browser downloads) and delete temp file afterward"""

    job = get_job(track_id)
    if not job:
        raise HTTPException(status_code=404, detail="Download not found")

    if job.get("status") != "completed":
        raise HTTPException(status_code=400, detail="File not ready for download")

    file_path = job.get("file_path")
    if not file_path or not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")

    # Decode URL-encoded filename for comparison
    decoded_filename = unquote(filename)
    actual_filename = os.path.basename(file_path)

    # Verify filename matches for security (compare decoded vs actual)
    if actual_filename != decoded_filename:
        raise HTTPException(status_code=400,
                            detail=f"Invalid filename. Expected: {actual_filename}, Got: {decoded_filename}")

    # Check if this is a temp file (for local downloads) - delete after serving
    # Normalize paths for comparison
    temp_dir_path = str(Path(config.DOWNLOAD_DIR) / "temp")
    is_temp_file = temp_dir_path in file_path or "temp" in os.path.dirname(file_path)

    # Return file for browser to download (saves to user's Downloads folder)
    # Use RFC 5987 encoding for non-ASCII filenames in Content-Disposition header
    # This handles special characters like ć, č, š, etc.
    ascii_filename = decoded_filename.encode('ascii', 'ignore').decode('ascii') or 'download.mp3'
    encoded_filename = quote(decoded_filename)

    response = FileResponse(
        file_path,
        media_type='audio/mpeg',
        filename=ascii_filename,  # Fallback ASCII filename
        headers={
            "Content-Disposition": f"attachment; filename=\"{ascii_filename}\"; filename*=UTF-8''{encoded_filename}"
        }
    )

    # Delete temp file after download completes (only for local downloads)
    if is_temp_file:
        background_tasks.add_task(cleanup_temp_file, file_path)

    return response


def cleanup_temp_file(file_path: str):
    """Clean up temporary download file after it's been served"""
    try:
        # Wait a moment to ensure file transfer is complete
        time.sleep(2)
        if os.path.exists(file_path):
            os.remove(file_path)
            print(f"Cleaned up temp file: {file_path}")
    except Exception as e:
        print(f"Error cleaning up temp file {file_path}: {e}")


@app.get("/api/track/{track_id}/exists")
async def check_track_exists(track_id: str):
    """Check if a track file already exists in downloads"""
    if not spotify_service:
        raise HTTPException(status_code=500, detail="Spotify service not configured")

    try:
        # Get track details from Spotify
        track_info = spotify_service.get_track_details(track_id)
        if not track_info:
            return {"exists": False}

        # Check if file exists
        download_path = get_download_path(track_info, config.DOWNLOAD_DIR, config.OUTPUT_FORMAT)
        file_exists = os.path.exists(download_path)

        return {
            "exists": file_exists,
            "file_path": download_path if file_exists else None
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error checking track: {str(e)}")


@app.get("/api/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "spotify_configured": spotify_service is not None,
        "navidrome_path": config.NAVIDROME_MUSIC_PATH
    }


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host=config.API_HOST, port=config.API_PORT)

